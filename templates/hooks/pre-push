#!/bin/sh
#
# Pre-push hook that runs tests and checks before allowing push
# Copy this file to .git/hooks/pre-push and make it executable
#

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

print_error() {
    echo -e "${RED}❌ $1${NC}"
}

print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

print_info() {
    echo "🔍 $1"
}

echo "🚀 Running pre-push checks..."

# Get information about what's being pushed
remote="$1"
url="$2"

# Read from stdin to get the list of refs being pushed
while read local_ref local_sha remote_ref remote_sha; do
    if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
        # Handle delete
        continue
    fi
    
    if [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
        # New branch, examine all commits
        range="$local_sha"
    else
        # Update to existing branch, examine new commits
        range="$remote_sha..$local_sha"
    fi
    
    # Check if there are any commits to push
    if [ -z "$range" ] || ! git rev-list --quiet "$range" 2>/dev/null; then
        continue
    fi
    
    print_info "Checking commits in range: $range"
    
    # Check 1: Ensure no debug code is being pushed
    print_info "Checking for debug code..."
    debug_files=$(git diff --name-only "$range" | xargs grep -l "console\.log\|debugger\|print(" 2>/dev/null || true)
    if [ -n "$debug_files" ]; then
        print_warning "Debug statements found in:"
        echo "$debug_files" | sed 's/^/  /'
        echo "Consider removing debug code before pushing"
        # Don't fail, just warn
    else
        print_success "No debug code detected"
    fi
    
    # Check 2: Ensure no TODO/FIXME in new code
    print_info "Checking for TODO/FIXME comments..."
    todo_count=$(git diff "$range" | grep -c "^\+.*\(TODO\|FIXME\|XXX\|HACK\)" || echo "0")
    if [ "$todo_count" -gt 0 ]; then
        print_warning "Found $todo_count new TODO/FIXME comments"
        echo "Consider addressing these before pushing to main branches"
        # Don't fail, just warn
    else
        print_success "No new TODO/FIXME comments"
    fi
    
    # Check 3: Verify commit message format (for main branches)
    if echo "$remote_ref" | grep -q "refs/heads/\(main\|master\|develop\)"; then
        print_info "Checking commit message format for main branch..."
        invalid_commits=$(git rev-list "$range" | while read commit; do
            msg=$(git log --format=%s -n 1 "$commit")
            if ! echo "$msg" | grep -qE '^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\(.+\))?: .{1,50}'; then
                echo "$commit: $msg"
            fi
        done)
        
        if [ -n "$invalid_commits" ]; then
            print_error "Invalid commit message format detected:"
            echo "$invalid_commits" | sed 's/^/  /'
            echo
            echo "Commit messages should follow conventional commit format:"
            echo "  type(scope): description"
            echo
            echo "Valid types: feat, fix, docs, style, refactor, test, chore, perf, ci, build, revert"
            exit 1
        else
            print_success "All commit messages follow conventional format"
        fi
    fi
    
    # Check 4: Run tests if available
    if [ -f "package.json" ] && grep -q '"test"' package.json; then
        print_info "Running tests..."
        if npm test; then
            print_success "All tests passed"
        else
            print_error "Tests failed"
            echo "Please fix failing tests before pushing"
            exit 1
        fi
    elif [ -f "Makefile" ] && grep -q "test:" Makefile; then
        print_info "Running tests via Makefile..."
        if make test; then
            print_success "All tests passed"
        else
            print_error "Tests failed"
            echo "Please fix failing tests before pushing"
            exit 1
        fi
    elif [ -f "pytest.ini" ] || [ -f "setup.cfg" ] || find . -name "test_*.py" -o -name "*_test.py" | head -1 | grep -q .; then
        print_info "Running Python tests..."
        if command -v pytest > /dev/null; then
            if pytest; then
                print_success "All Python tests passed"
            else
                print_error "Python tests failed"
                echo "Please fix failing tests before pushing"
                exit 1
            fi
        else
            print_warning "pytest not found, skipping Python tests"
        fi
    else
        print_info "No test configuration found, skipping tests"
    fi
    
    # Check 5: Run linting if available
    if [ -f "package.json" ] && grep -q '"lint"' package.json; then
        print_info "Running linter..."
        if npm run lint; then
            print_success "Linting passed"
        else
            print_error "Linting failed"
            echo "Please fix linting errors before pushing"
            exit 1
        fi
    elif [ -f ".eslintrc.js" ] || [ -f ".eslintrc.json" ] || [ -f ".eslintrc.yml" ]; then
        if command -v eslint > /dev/null; then
            print_info "Running ESLint..."
            if eslint .; then
                print_success "ESLint passed"
            else
                print_error "ESLint failed"
                echo "Please fix linting errors before pushing"
                exit 1
            fi
        fi
    elif [ -f ".flake8" ] || [ -f "setup.cfg" ] || [ -f "tox.ini" ]; then
        if command -v flake8 > /dev/null; then
            print_info "Running flake8..."
            if flake8; then
                print_success "flake8 passed"
            else
                print_error "flake8 failed"
                echo "Please fix linting errors before pushing"
                exit 1
            fi
        fi
    else
        print_info "No linting configuration found, skipping linting"
    fi
    
    # Check 6: Verify no large files are being added
    print_info "Checking for large files..."
    large_files=$(git diff --name-only "$range" | xargs -I {} find {} -size +10M 2>/dev/null || true)
    if [ -n "$large_files" ]; then
        print_error "Large files detected (>10MB):"
        echo "$large_files" | sed 's/^/  /'
        echo
        echo "Consider using Git LFS for large files:"
        echo "  git lfs track '*.zip'"
        echo "  git add .gitattributes"
        exit 1
    else
        print_success "No large files detected"
    fi
    
    # Check 7: Ensure no sensitive files are being pushed
    print_info "Checking for sensitive files..."
    sensitive_patterns="\.env$|\.key$|\.pem$|\.p12$|\.pfx$|password|secret|credentials"
    sensitive_files=$(git diff --name-only "$range" | grep -E "$sensitive_patterns" || true)
    if [ -n "$sensitive_files" ]; then
        print_error "Potentially sensitive files detected:"
        echo "$sensitive_files" | sed 's/^/  /'
        echo
        echo "Please verify these files don't contain sensitive information"
        echo "Consider adding them to .gitignore if they shouldn't be tracked"
        exit 1
    else
        print_success "No sensitive files detected"
    fi
    
    # Check 8: Branch protection for main branches
    if echo "$remote_ref" | grep -q "refs/heads/\(main\|master\)"; then
        current_branch=$(git branch --show-current)
        if [ "$current_branch" = "main" ] || [ "$current_branch" = "master" ]; then
            print_warning "Pushing directly to main branch"
            echo "Consider using feature branches and pull requests for better collaboration"
        fi
    fi
    
done

print_success "All pre-push checks passed!"
print_info "Push will proceed..."

exit 0
